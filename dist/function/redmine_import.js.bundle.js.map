{"version":3,"file":"function/redmine_import.js.bundle.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://gitlab_time_spend/./src/function/redmine_import.js"],"sourcesContent":["\nvar timeInputTable\n\n$(document).ready(() => {\n\ttimeInputTable = new TimeInputTable('time_input_table')\n\tinsertTextArea()\n\taddEventListener()\n})\n\nasync function inputWorkingTime(issueId, spendHour, comment){\n\tlet targetRow = timeInputTable.findAvailableRow(issueId)\n\tif(targetRow == -1){\n\t\t// 行自体が無かった時の処理\n\t\tawait RedmineClient.ajaxInsertTickets(issueId)\n\t\ttimeInputTable.refresh()\n\t\ttargetRow = timeInputTable.findAvailableRow(issueId)\n\t}\n\tif(targetRow.isInputed()){\n\t\t// 行はあるが既に入力されているので、行を新しく追加し入力するときの処理\n\t\tconst dup_id = new RowId(targetRow.getId())\n\t\t// FIXME: Redmineと通信する用のクラスを作成したのでそちらに寄せる\n\t\tconst url = '/work_time/ajax_add_tickets_insert' + location.search\n\t\tawait targetRow.dup_ticket(url, dup_id.toString(), dup_id.getIssueId())\n\n\t\tconst dupRowElm = document.querySelector('#' + dup_id.toStringNextIndex())\n\t\t\t, dupRow = new TimeInputTableRow(dupRowElm)\n\t\tdupRow.addSpendTime(spendHour)\n\t\tdupRow.addComment(comment)\n\t\ttimeInputTable.add(dupRow)\n\n\t} else {\n\t\t// 入れれるとき\n\t\ttargetRow.addSpendTime(spendHour)\n\t\ttargetRow.addComment(comment)\n\t}\n\t\n}\n\nfunction insertTextArea(){\n\t// 可読性優先でベタ書き\n\tconst memo = `\n\t\t<div><textarea id=\"autoInputTextArea\" rows=\"10\" style=\"width:100%\"></textarea>\n\t\t<br>\n\t\t<input id=\"autoInputButton\" type=\"button\" value=\"自動入力＾＾\"></input>\n\t\t</div>\n\t`\n\tjQuery('#time_input_table').before(memo)\n\t\n\t// 以下テスト用\n\tconst workingTimes = `\n\t\t{\n\t\t\t\"issueId\" : \"157608\",\n\t\t\t\"spendTime\" : 1,\n\t\t\t\"comment\" : \"テスト追加1\"\n\t\t},\n\t\t{\n\t\t\t\"issueId\" : \"157608\",\n\t\t\t\"spendTime\" : 2,\n\t\t\t\"comment\" : \"テスト追加2\"\n\t\t}\n\t`\n\tjQuery('#autoInputTextArea').val(workingTimes)\n}\n\nfunction input(jsons){\n\tlet promise = Promise.resolve()\n\tjsons.forEach((json) => {\n\t\tconst issueId = json.issueId\n\t\t\t, spendTime = json.spendTime\n\t\t\t, comment = json.comment\n\t\tpromise = promise.then(inputWorkingTime.bind(this, issueId, spendTime, comment))\n\t})\n}\n\nfunction addEventListener(){\n\tjQuery('#autoInputButton').on('click', () =>  {\n\t\tconst inputText = jQuery('#autoInputTextArea').val()\n\t\tif(inputText != \"\"){\n\t\t\tinput(JSON.parse(inputText))\n\t\t}\n\t  })\n}\n\n/**\n * 行のIDを表すドメイン\n * ルールにのっとってるっぽいのでこちらで表現\n */\n class RowId{\n\tconstructor(string){\n\t\tconst splited = string.match(/^time_entry_pos(\\d+)_(\\d+)$/)\n\t\tthis.issueId = splited[1]\n\t\tthis.index = Number(splited[2])\n\t}\n\n\tgetIssueId(){\n\t\treturn this.issueId\n\t}\n\n\tgetIndex(){\n\t\treturn this.index\n\t}\n\n\t// ex. time_entry_pos157608_0\n\ttoString(){\n\t\treturn RowId.PREFIX() + this.issueId + '_' + this.index\n\t}\n\n\t// ex. time_entry_pos157608_1\n\ttoStringNextIndex(){\n\t\tconst nextIndex = Number(this.index) + 1\n\t\treturn RowId.PREFIX() + this.issueId + '_' + nextIndex\n\t}\n\n\t// ex. new_time_entry_157608_0_hours\n\tspentTimeId(){\n\t\treturn 'new_time_entry_' + this.issueId + '_' + this.index +  '_hours'\n\t}\n\n\t// ex. new_time_entry_157608_0_comments\n\tcommentId(){\n\t\treturn 'new_time_entry_' + this.issueId + '_' + this.index +  '_comments'\n\t}\n\n\tstatic PREFIX(){\n\t\treturn 'time_entry_pos'\n\t}\n}\n\nclass TimeInputTable{\n\tconstructor(id){\n\t\tthis.id = id\n\t\tthis.dom = null\n\t\tthis.rows = []\n\t\tthis.refresh()\n\t}\n\n\t/**\n\t * 行を追加する\n\t * @param {*} timeInputTableRow\n\t */\n\tadd(timeInputTableRow){\n\t\tthis.rows.push(timeInputTableRow)\n\t}\n\n\t/**\n\t * チケット番号で行を検索する(複数あったらIndex最大のものを返す)\n\t * 無い場合は-1が返る\n\t * @param {number} issueId \n\t */\n\tfindAvailableRow(issueId){\n\t\tlet maxIndexRows = -1\n\t\tconst filterdRows = this.rows.filter(row => row.getIssueId() == issueId)\n\t\tif(filterdRows.length){\n\t\t\tmaxIndexRows = filterdRows[0];\n\t\t\tfilterdRows.forEach((row) => {\n\t\t\t\tif(row.getIndex() > maxIndexRows.getIndex()){\n\t\t\t\t\tmaxIndexRows = row\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\treturn maxIndexRows\n\t}\n\n\trefresh(){\n\t\tthis.dom = document.getElementById(this.id)\n\t\tthis.rows = []\n\t\tconst rowId = `[id^='` + RowId.PREFIX() + `']`\n\t\tconst rowElements = this.dom.querySelectorAll(rowId);\n\t\trowElements.forEach((e) => {\n\t\t\tthis.add(new TimeInputTableRow(e))\n\t\t})\n\t}\n\n\t/**\n\t * 行を新規追加する\n\t */\n\tasync tickets_insert()\n\t{\n\t\t//TODO\n\t}\n}\n\nclass TimeInputTableRow{\n\tconstructor(dom){\n\t\tthis.dom = dom\n\t\tconst domId = dom.getAttribute('id') // time_entry_pos157608_0\n\t\tthis.ids = new RowId(domId)\n\t\tthis.spendTimeid = '#' + this.ids.spentTimeId()\n\t\tthis.commentid = '#' + this.ids.commentId()\n\t}\n\n\tgetId(){\n\t\treturn this.ids.toString()\n\t}\n\n\tgetIssueId(){\n\t\treturn this.ids.getIssueId()\n\t}\n\n\tgetIndex(){\n\t\treturn this.ids.getIndex()\n\t}\n\n\t/**\n\t * 入力済みかどうか\n\t */\n\tisInputed(){\n\t\tconst commented = this.dom.querySelector(this.commentid).value != \"\"\n\t\t, spented = this.dom.querySelector(this.spendTimeid).value != \"\"\n\t\treturn commented || spented\n\t}\n\n\t/**\n\t * 工数を入力する\n\t * @param {Number} hour \n\t */\n\taddSpendTime(hour){\n\t\tthis.dom.querySelector(this.spendTimeid).value = hour\n\t}\n\n\t/**\n\t * コメントを入力する\n\t * @param {string} comment \n\t */\n\taddComment(comment){\n\t\tthis.dom.querySelector(this.commentid).value = comment\n\t}\n\n\t/**\n\t * 行を複製する（＋ボタン押したのと同じ動き）\n\t * redmine純正のメソッド。仕様変更されたら使えない\n\t */ \n\t async dup_ticket(ajax_url, insert_pos, id)\n\t {\n\t\t const add_ticket_count = this.ids.getIndex() + 1\n\t\t await jQuery.ajax({\n\t\t\t url:ajax_url+\"&add_issue=\"+id+\"&count=\"+add_ticket_count,\n\t\t\t data:{asynchronous:true, method:'get'},\n\t\t\t success:function(response){\n\t\t\t\t jQuery('#'+insert_pos).after(response);\n\t\t\t }\n\t\t });\n\t }\n}\n\n/**\n * 時間を表すドメイン\n */\nclass Time{\n\tconstructor(second){\n\t\tthis.s = second\n\t}\n\n\tgetSecond(){\n\t\treturn this.s / (60*60)\n\t}\n\n\tgetHour(){\n\t\treturn this.s / (60*60)\n\t}\n\n\tgetMinute(){\n\t\treturn this.s / 60\n\t}\n}\n\n/**\n * RedmineAPIとのやりとりを担当するクラス\n * Redmine側の仕様変更があってもここを修正すれば対応できるはず\n */\nclass RedmineClient{\n\n\tstatic canInputTicket = false\n\tstatic add_ticket_count = 1\n\n\t/**\n\t * 新規チケット追加フォームを開く\n\t * FIXME: 開かなくてもチケット新規追加出来たっぽい。消す\n\t */\n\tstatic async ajaxAddTicketsInput(){\n\t\tconst ajax_url = '/work_time/ajax_add_tickets_input'\n\t\tawait jQuery.ajax({\n\t\t\turl: ajax_url,\n\t\t\tdata:{asynchronous:true, method:'get'},\n\t\t\tsuccess: function(response){\n\t\t\t\tjQuery('#add_ticket_area').replaceWith(response);\n\t\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * チケットを新規追加する\n\t * @param {*} issueId\n\t * @returns \n\t */\n\t// 純正メソッド参考: function tickets_insert(ajax_url, tickets)\n\tstatic async ajaxInsertTickets(issueId){\n\t\tconst ajax_url = '/work_time/ajax_add_tickets_insert' + location.search\n\t\tawait jQuery.ajax({\n\t\t\turl:ajax_url+\"&add_issue=\"+issueId+\"&count=\"+RedmineClient.add_ticket_count,\n\t\t\tdata:{asynchronous:true, method:'get'},\n\t\t\tsuccess:function(response){\n\t\t\tjQuery('#time_input_table_bottom').before(response);\n\t\t\t}\n\t\t});\n\t\tRedmineClient.add_ticket_count ++;\n\t}\n}"],"names":[],"sourceRoot":""}